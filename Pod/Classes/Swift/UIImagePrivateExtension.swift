//
//  UIImage+ChameleonPrivate.m
//  Chameleon
//
//  Created by Vicc Alexander on 6/8/15.
//  Copyright (c) 2015 Vicc Alexander. All rights reserved.
//

import UIKit

infix operator +&& {}
func +&& (lhs: CGFloat, rhs: CGFloat) -> CGFloat {
    let currentValue = abs(lhs + rhs)
    
    //Check if currentValue exceeds 360 degrees
    if currentValue > 360 {
        return currentValue - 360
    } else {
        return currentValue
    }
}

public extension UIImage {
    
    // Would not have been possible without - http://stackoverflow.com/a/25146557
    func getPixelColor(pos: CGPoint) -> UIColor {
        let pixelData = CGDataProviderCopyData(CGImageGetDataProvider(self.CGImage))
        let data: UnsafePointer<UInt8> = CFDataGetBytePtr(pixelData)
        
        let pixelInfo: Int = ((Int(self.size.width) * Int(pos.y)) + Int(pos.x)) * 4
        
        let r = CGFloat(data[pixelInfo]) / CGFloat(255.0)
        let g = CGFloat(data[pixelInfo+1]) / CGFloat(255.0)
        let b = CGFloat(data[pixelInfo+2]) / CGFloat(255.0)
        let a = CGFloat(data[pixelInfo+3]) / CGFloat(255.0)
        
        return RGBa(r, g, b, a)
    }
    
    class func imageWithImage(image: UIImage, scaledToSize newSize: CGSize) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.drawInRect(CGRectMake(0, 0, newSize.width, newSize.height))
        
        let newImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()

        return newImage
    }
    
    func imageScaledToSize(scaledToSize newSize: CGSize) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        self.drawInRect(CGRectMake(0, 0, newSize.width, newSize.height))
        
        let newImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return newImage
    }
    
    /**
    *  Returns the average color generated by averaging the colors of a specified image.
    *
    *  @param alpha The opacity.
    *
    *  @return A flat @c UIColor object in the HSB colorspace.
    *
    *  @since 2.0
    */
    func averageColorFromImage(withAlpha alpha:CGFloat = 1.0) -> UIColor {
        //Work within the RGB colorspoace
        var rgba = [UInt8](count: 4, repeatedValue: 0)
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo.ByteOrder32Big.rawValue | CGBitmapInfo(rawValue: CGImageAlphaInfo.PremultipliedLast.rawValue).rawValue
        let context = CGBitmapContextCreate(&rgba, 1, 1, 8, 4, colorSpace, bitmapInfo)
        
        //Draw our image down to 1x1 pixels
        CGContextDrawImage(context, CGRectMake(0, 0, 1, 1), CGImage)
        
        let averageColor:UIColor
        if rgba[3] == 0 { //Check if image alpha is 0
            let imageAlpha = CGFloat(rgba[3])/255
            let multiplier = imageAlpha/255
            
            averageColor = RGBa(CGFloat(rgba[0]) * multiplier, CGFloat(rgba[1]) * multiplier, CGFloat(rgba[2]) * multiplier, imageAlpha)
        } else {
            //Get average
            averageColor = RGBa(CGFloat(rgba[0]) / 255, CGFloat(rgba[1]) / 255, CGFloat(rgba[2]) / 255, alpha)
        }
        
        //Return improved average color
        return averageColor.colorWithMinimumSaturation(0.15)
    }
    
    func colorsFromImage(useFlatScheme isFlatScheme:Bool) -> [UIColor] {
        var foundImageColors:[UIColor] = []
        
        //Scale image
        let scaledImage = imageScaledToSize(scaledToSize: CGSizeMake(size.width/8, size.height/8))
        
        //Find colors in image *********************************
        
        //Get dimensions of image in pixels
        let width  = CGImageGetWidth(scaledImage.CGImage)
        let height = CGImageGetHeight(scaledImage.CGImage)
        
        //Initialize a counted set with the correct capacity
        let imageColors = NSCountedSet(capacity: (width * height))
        
        //Loop through each column
        for x in 0..<width {
            //Loop through each row
            for y in 0..<height {
                //Get color at a specific point
                let color = UIColor(image:scaledImage, atPoint:CGPointMake(CGFloat(x), CGFloat(y)))
                
                //Add color to our list of all pixel colors
                imageColors.addObject(color)
            }
        }
        
        //Setup up an enumerator object
        let sortedColors = NSCountedSet(capacity:imageColors.count)
        var resultColors:[UIColor] = []
        
        //Enumerate through each object once
        imageColors.forEach { someColor in
            //Set a minimum allowed saturation
            let currentColor = (someColor as! UIColor).colorWithMinimumSaturation(0.15)
            
            //Get color count
            //            let colorCount = imageColors.countForObject(currentColor)
            
            //Add them to our sortedColors array
            sortedColors.addObject(currentColor)
        }
        
        //Sort Colors
        //        sortedColors sortUsingSelector:@selector(compare:)];
        
        //Loop through our sorted colors
        for countedColor in sortedColors {
            
            //Define our current color
            //            currentColor = countedColor.color;
            let currentColor = countedColor as! UIColor
            
            //Setup a flag to see if we should continue counting
            var continueFlag = false
            
            //Loop through our colors
            for otherColor in resultColors {
                
                //If our current color differs from our last, break the loop
                if !currentColor.isDistinct(otherColor) {
                    continueFlag = true
                    break
                }
            }
            
            //Continue
            if continueFlag {
                continue
            }
            
            //If we can still add more colors, do so
            if resultColors.count < 5 {
                //Check if we should flatten our color
                if isFlatScheme {
                    resultColors.append(currentColor.flatten())
                } else {
                    resultColors.append(currentColor)
                }
            } else {
                break
            }
        }
        
        //Get colors from image
        foundImageColors.appendContentsOf(resultColors)
        
        // *****************************************************
        
        //Make sure we add white colors in case we're missing colors
        while foundImageColors.count < 5 {
            foundImageColors.append(UIColor.whiteColor())
        }
        
        return foundImageColors
    }
    
    func findColors() -> [UIColor] {
        //Find colors in image *********************************
        
        //Get dimensions of image in pixels
        let width  = CGImageGetWidth(CGImage)
        let height = CGImageGetHeight(CGImage)
        
//        var colors = NSCountedSet(capacity: width * height)
        //Initialize a counted set with the correct capacity
        let imageColors = NSCountedSet(capacity: width * height)
        
        //Loop through each column
        for x in 0..<width {
            //Loop through each row
            for y in 0..<height {
                //Get color at a specific point
                let color = UIColor(image:self, atPoint:CGPointMake(CGFloat(x), CGFloat(y)))
                
                //Add color to our list of all pixel colors
                imageColors.addObject(color)
            }
        }
        
        //Setup up an enumerator object
        let sortedColors = NSCountedSet(capacity:imageColors.count)
        var resultColors:[UIColor] = []
        
        //Enumerate through each object once
        imageColors.forEach { someColor in
            //Set a minimum allowed saturation
            let currentColor = (someColor as! UIColor).colorWithMinimumSaturation(0.15)
            
            //Get color count
            //            let colorCount = imageColors.countForObject(currentColor)
            
            //Add them to our sortedColors array
            sortedColors.addObject(currentColor)
        }
        
        //Sort Colors
        //        sortedColors sortUsingSelector:@selector(compare:)];
        
        //Loop through our sorted colors
        for countedColor in sortedColors {
            
            //Define our current color
            //            let currentColor = countedColor.color
            let currentColor = countedColor as! UIColor
            
            //Setup a flag to see if we should continue counting
            var continueFlag = false
            
            //Loop through our colors
            for otherColor in resultColors {
                
                //If our current color differs from our last, break the loop
                if !currentColor.isDistinct(otherColor) {
                    continueFlag = true
                    break
                }
            }
            
            //Continue
            if continueFlag {
                continue
            }
            
            //If we can still add more colors, do so
            if resultColors.count < 5 {
                resultColors.append(currentColor)
            } else {
                break
            }
        }
        
        //Return our colors
        return resultColors
    }
}
